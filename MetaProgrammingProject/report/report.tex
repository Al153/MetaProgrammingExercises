\documentclass{report}
\usepackage{amssymb}

\usepackage{amsmath}
\usepackage[a4paper,includeheadfoot,margin=2.54cm]{geometry}
\usepackage{breqn}

\usepackage{array}   % for \newcolumntype macro

\usepackage{verbatim}

\usepackage{tabstackengine}
\setstackEOL{\cr}
\setstackgap{L}{\normalbaselineskip}




\newcommand\N[0]{\mathbb{N}}
\newcommand\Q[0]{\mathbb{Q}}

\newcommand \2[0]{\textbf{2}}
\newcommand \3[0]{\textbf{3}}


\newcommand\biimpl[0]{\Leftrightarrow}
\newcommand\impl[0]{\Rightarrow}
\newcommand\impliedBy[0]{\Leftarrow}
\newcommand \inverse[0]{^{-1}}
\newcommand \compose[0]{ \circ}

\newcommand \op[0]{^{op}}

\newcommand \cat[0]{\textbf{C}}
\newcommand \cset[0]{\textbf{Set}}

\newcommand{\todo}[1]{\textbf{#1}}

\begin{document}
\title{A Modular, Extensible, and Polymorphic Graph Query DSL}

\todo{
    \begin{itemize}
        \item More signposting
        \item Free optimisation?
        \item Polymorphic optimisations?
        \item First class relations? 
        \item Compiled backend example.
    \end{itemize}
}

\abstract
This project is an extension of my Part II project \footnote{Dissertation: https://github.com/Al153/PartIIProject/blob/master/diss/diss.pdf,\\ Code: https://github.com/Al153/PartIIProject/tree/master/src}, the purpose of which was to build a purely functional graph database system. Although the DSL I produced for the project did provide Scala-compile-time type checking, it used an ADT to construct DSL terms and hence was not tagless-final. Further more, the DSL required implementations to return values of a specific monad type, which made it unsuitable for implementations other than immediate interpreters, such as an implementation that compiles queries for later execution. While my Part II project focused on the full stack and optimisations of particular backends, this L305 project focuses on the front end of a graph database system. The project's primary aim is to make open up the interface of the DSL to more varied implementation. It replicates the original DSL in a Modular tagless-final fashion, allowing implementations to choose which operations and syntax they support. Furthermore, it provides a high degree of polymorphism, both in the types used to represent queries, the return types of the database, and in the typeclasses used by an implementation to classify which types can be stored in the database. The project also contains code to plug in my part II backends to use the new DSL. Finally, the project also contains "free" implementations of modules and a suite of "free" optimisations.

\chapter{The Original Project}
\section{Introduction}
My original part II project built the full stack of a graph database system. It provided a strongly typed DSL, a type-class based framework for allowing an application developer's types to be used in queries, and several different backends targeting an in-memory datastore, PostgreSQL, and the LMDB memory-mapped datastore. This project acts as a DSL generator of sorts for faster, more consistent generation of  DSLs for graph-query executors.
\subsection{The Query Language}
The original project uses an algebraic-datatype-based query language to specify queries that search for pairs of related objects and individual objects. As defined in my dissertation, the basic query constructors are as follows.
\begin{equation}
    \label{PDefinition}
    \begin{split}
    P  &\rightarrow Rel(R) \mbox{ Find pairs related by the named relation R}\\
    &\mid RevRel(R) \mbox{ Find pairs related by the named relation R in the reverse direction}\\
    &\mid Chain(P, P) \mbox{   Find pairs related by the first subquery followed by the second}\\
    &\mid And(P, P) \mbox{  Find pairs related by both of the sub-queries}\\
    &\mid AndRight(P, S) \mbox{  Find pairs related by P where the right value is a result of S}\\
    &\mid AndLeft(P, S) \mbox{  Find pairs related by P where the left value is a result of S}\\
    &\mid Or(P, P) \mbox{  Find pairs related by either of the sub-queries}\\
    &\mid Distinct(P) \mbox{  Find pairs related by P that are not symmetrical}\\
    &\mid Id_A \mbox{ Identity relation}\\
    &\mid Exactly(\mathit{n}, P) \mbox{  Find pairs related by n repetitions of P}\\
    &\mid Upto(\mathit{n}, P) \mbox{  Find pairs related by up to n repetitions of P}\\
    &\mid FixedPoint(P) \mbox{  Find the transitive closure of P}\\
    \end{split}
    \end{equation} 

    \begin{equation}
        \label{SDefinition}
        \begin{split}
        S & \rightarrow Find(F) \mbox{ Find values that match the findable F}\\
        &\mid From(S, P) \mbox{ Find values that are reachable from results of S via P}\\
        &\mid AndS(S, S) \mbox{ Find values that are results of both subqueries}\\
        &\mid OrS(S, S) \mbox{ Find values that are results of either subquery}
        \end{split}
    \end{equation} 

Full details, including the type system that applies over this query language can be found in \todo{Section of my dissertation}. Once a query is built, it may be executed in one of several ways by the \texttt{\todo{DBExecutor}} of a given implementation. For example, the executor may simply read the queries from the database or perhaps do pathfinding over the graph with the queries.
\section{Flaws in the Project}
There are several flaws in the front end of this project, as necessitated by the time constraints of a part II project, as well as my desire to look at the big picture of the system rather than focusing for too long on the front end.
\subsection{Fixed Query ADT}
The original project constructed a fixed ADT representing each query. ADT was then traversed or otherwise evaluated to interpret the results of the query. In order to get pattern-match-exhaustivity checking, one has to seal a trait in Scala. This means that the ADT backing the DSL is fixed and cannot be directly extended or reduced. A tagless-final DSL is much easier to extend or reduce.

\subsection{Lack of Polymorphism}
the lack of polymorphism in the original DSL puts unnecessary constraints on back-end implementation.
\paragraph{Types Stored in the Database}
The original project uses the \texttt{SchemaObject} type-class to specify which types can be stored in the database. This type-class is fixed, only allowing types that can be represented as tuples of simple primitive types to be stored in the database. Allowing polymorphism over the type-class used to verify types manipulated by the DSL allows for more freedom of implementation. For example, we may choose to store more complex types to the database, such as wide floating point values, or higher order relations.

\paragraph{Fixed Return Types}
The original database interface requires implementations to return instances of the specific \texttt{Operation} monad (a stack of asynchrony, state, error monads). And only allows read operations to return the eager \texttt{Set} type of results. That is, the return type is \texttt{Operation[Error, Set[(A, B)]]}. This specific return type constraint prevents implementors from returning more interesting values, such as compiled code for later use, or lazy alternatives to sets. Furthermore, it locked the implementation into using the same monadic, branching time, update semantics specified by the \texttt{Operation} monad.

\chapter{The New DSL}
This section introduces the new structure of the DSL.
 
\section{Tagless-Final}
The new DSL is a modular tagless-final based system. There are several traits to implement, each containing a subset of the operations defined above. This allows for implementations to only partially implement the specification or to add new modules.
The DSL is polymorphic in the type constructors \texttt{Pair} and \texttt{Single} which are used to specify queries returning pairs or single objects. This allows more flexibility than the original ADT based interface.

\section{Modularity}
The new DSL framework is built in a modular way. 
Allows more freedom to implementors to pick and choose which functionality they want to provide to the database system. This allows more specific DSLs to be designed to use particular parts of the algebra.
\subsection{Important Classes/Types/Traits}
\paragraph{Query Building}
The tagless-final interface for building queries is separated into several pieces.
\todo{Check names}
\begin{itemize}
    \item \textbf{Simple Pairs} - \texttt{and}, \texttt{or}, \texttt{id}, etc.
    \item \textbf{Singles} - All of the single query combinators.
    \item \textbf{Simple Repetitions} - \texttt{upto}, \texttt{exactly}
    \item \textbf{Fixed Point} - \texttt{fixedpoint}
\end{itemize}

This allows implementors to implement the interfaces in separate parts. It also allows for construction of less expressive DSLs, for example, without the fixed point combinator.

\paragraph{Execution}
The methods for interpreting a query are separated out into separate interfaces for each function, straight interpretation of queries, path-finding using queries, and updates to the database. These are separated as in the case of queries to allow for partial implementation.

\begin{itemize}
    \item collection of assertion and boolean test modules allowing the construction of a unit testing framework.
    \item Currying module?
    \item simple Monad typeclass for specifying the output type.
    \item \todo{there's more  I think}
\end{itemize}

\subsection{Dependency Management}
This module system allows us to delegate dependency management to the type system. Each module is designed as a mix-in trait.

\begin{itemize}
\item Allows backend implementors to partially implement the specification and only provide operations that make sense for the given back end.
\item Allows backend implementors to additional module that make sense
\item Dependency management is deferred to the Scala type-system using mix-in traits.
\item In a language like java, similar, objects with a large variety of options are implemented at the value level, requiring runtime checking and the ugly use of exceptions etc.
\item Each trait gives its dependencies as self-mix-ins.
\end{itemize}

\section{Syntax}
\begin{itemize}
    \item Each module comes with a syntax provider, which provides the appropriate implicit conversions to add the original DSL syntax to the arbitrary types.
    \item Uses a "With-module" mix in system, meaning that the syntax provider just needs to be mixed in to provide the appropriate syntax methods.
    \item Dependency checking is done by the Scala type system/compiler
    \item Syntax is provided "locally" rather than "globally" to put less pressure on Scala's type inference, due to the many type variables that need to be inferred.
\end{itemize}

\section{Polymorphism}
A lot of this flexibility and deferral to the scala type system is made possible by the large amount of polymorphism allowed in the system. Each trait is polymorphic in as many variables as possible in order to generalise the system to the greatest extent.
\begin{itemize}
    \item Polymorphic in much more than just query types
    \item Polymorphic in the verification type-class, so implementations can define ways to store or query over all sorts of values. E.G. could store relations as objects. (think exponential objects in categories) Previously, only simple tuple types could be stored in a given database.
    \item Polymorphic in return-set type so back-ends can provide lazy or compiled implementations. The original system required an eagerly evaluated set.
    \item Polymorphic on return monad, so implementations can specify what level of error-handling/typing strength they want - can start by using exceptions to handle errors. Could also use the either monad or similar to express computations. Can use state monad or similar to compile the code into something more interesting.
    \item Having lots of polymorphic type parameters makes it harder for the scala type system to infer types, which would litter queries in the generated DSL with type annotations. Sub optimal.
    \item\todo{Examples}
\end{itemize}

\section{Testing}
\begin{itemize}
    \item Provides modules for assertions and a testing framework
    \item \todo{Rewrite Part II testing framework as a mix-in module}
\end{itemize}

\chapter{Back-end implementations}

I've provided several simple implementations for this project to showcase features.
\section{Trivial implementation}
The first implementation is one that trivially uses sets  to store objects in memory. The validity type-class is the "Universe" type class that verifies that there exists a finite universe of objects of the parameter type in memory. This implementation uses simple techniques to generate the DSL in a free manner.

\section{Original Back-End}
A second implementation is one that provides a set of connectors to allow a suitable DB instance to be used as as a L305-Project DSL instance. This is a simple case of deferring to the instance's original methods.


\chapter{Free Implementations}
Some modules of DSL implementations can be defined naturally in terms of other modules. For example, as proven in the original project \todo{Which section?}, one can formulate the \texttt{exactly(n, P)} operation as a collection of \texttt{chain} operations. Furthermore, one can formulate \texttt{upto(n, P)} as \texttt{exactly(n, or(p, Id))}. Hence we can freely implement \texttt{exactly} and \texttt{upto} given an implementation of the \texttt{SimplePairs} module. Free implementations give us combinators for generating default methods of DSLs in a clean manner.

In general, we can construct a free implementation of a trait using mix-ins as follows:

\begin{verbatim}
trait Free[TypeParams] extends ToBeImplemented[Types] {
    self: Dependency1[Types1] with Dependency2[Types2] =>
    // implement the methods of `ToBeImplemented` using 
    // methods of `Dependency1` and `Dependency1`
    def foo[A, B](a: A): B = ...
}
\end{verbatim}

A free implementation can be used by mixing it in with implementations of the required dependencies.

\begin{verbatim}
object MyDSL extends Dependency1[Types1] with Dependency2[Types2] with Free[Types]
\end{verbatim}

One downside to overuse of free implementations is that they may not provide well optimised or performant queries for particular back ends. For example, it may be possible to carry out a backend-specific optimisation that is not applicable in the general case.

\chapter{Free Optimisations}
There currently exist (and it may be possible to find more) examples of queries which can be optimised across many implementations. Hence I've constructed a combinator for applying simple optimisations. \todo{Actually build this}
    
\end{document}
